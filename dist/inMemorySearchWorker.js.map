{"version":3,"file":"inMemorySearchWorker.js","mappings":"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","sources":["webpack://openmct/webpack/universalModuleDefinition","webpack://openmct/./src/api/objects/InMemorySearchWorker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"openmct\"] = factory();\n\telse\n\t\troot[\"openmct\"] = factory();\n})(this, () => {\nreturn ","/*GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007/<MCT>  Copyright (C) Mon Apr  3 07:01:31 AM PDT 2023 shaynababe\nThis program comes with ABSOLUTELY NO WARRANTY; for details type pnpm install.\nThis is free software, and you are welcome to redistribute it \nunder certain conditions; type pnpm start for details.<MCT>  Copyright (C) Mon Apr  3 07:01:31 AM PDT 2023 shaynababe */\n\n\n/**\n * Module defining InMemorySearchWorker. Created by deeptailor on 10/03/2019.\n */\n(function () {\n    // An object composed of domain object IDs and models\n    // {id: domainObject's ID, name: domainObject's name}\n    const indexedDomainObjects = {};\n    const indexedAnnotationsByDomainObject = {};\n    const indexedAnnotationsByTag = {};\n\n    self.onconnect = function (e) {\n        const port = e.ports[0];\n\n        port.onmessage = function (event) {\n            const requestType = event.data.request;\n            if (requestType === 'index') {\n                indexItem(event.data.keyString, event.data.model);\n            } else if (requestType === 'OBJECTS') {\n                port.postMessage(searchForObjects(event.data));\n            } else if (requestType === 'ANNOTATIONS') {\n                port.postMessage(searchForAnnotations(event.data));\n            } else if (requestType === 'TAGS') {\n                port.postMessage(searchForTags(event.data));\n            } else {\n                throw new Error(`Unknown request ${event.data.request}`);\n            }\n        };\n\n        port.start();\n\n    };\n\n    self.onerror = function (error) {\n        //do nothing\n        console.error('Error on feed', error);\n    };\n\n    function indexAnnotation(objectToIndex, model) {\n        Object.keys(model.targets).forEach(targetID => {\n            if (!indexedAnnotationsByDomainObject[targetID]) {\n                indexedAnnotationsByDomainObject[targetID] = [];\n            }\n\n            objectToIndex.targets = model.targets;\n            objectToIndex.tags = model.tags;\n            const existsInIndex = indexedAnnotationsByDomainObject[targetID].some(indexedObject => {\n                return indexedObject.keyString === objectToIndex.keyString;\n            });\n\n            if (!existsInIndex) {\n                indexedAnnotationsByDomainObject[targetID].push(objectToIndex);\n            }\n        });\n    }\n\n    function indexTags(keyString, objectToIndex, model) {\n        // add new tags\n        model.tags.forEach(tagID => {\n            if (!indexedAnnotationsByTag[tagID]) {\n                indexedAnnotationsByTag[tagID] = [];\n            }\n\n            const existsInIndex = indexedAnnotationsByTag[tagID].some(indexedObject => {\n                return indexedObject.keyString === objectToIndex.keyString;\n            });\n\n            if (!existsInIndex) {\n                indexedAnnotationsByTag[tagID].push(objectToIndex);\n            }\n\n        });\n        // remove old tags\n        const tagsToRemoveFromIndex = Object.keys(indexedAnnotationsByTag).filter(indexedTag => {\n            return !(model.tags.includes(indexedTag));\n        });\n        tagsToRemoveFromIndex.forEach(tagToRemoveFromIndex => {\n            indexedAnnotationsByTag[tagToRemoveFromIndex] = indexedAnnotationsByTag[tagToRemoveFromIndex].filter(indexedAnnotation => {\n                const shouldKeep = indexedAnnotation.keyString !== keyString;\n\n                return shouldKeep;\n            });\n        });\n    }\n\n    function indexItem(keyString, model) {\n        const objectToIndex = {\n            type: model.type,\n            name: model.name,\n            keyString\n        };\n        if (model && (model.type === 'annotation')) {\n            if (model.targets) {\n                indexAnnotation(objectToIndex, model);\n            }\n\n            if (model.tags) {\n                indexTags(keyString, objectToIndex, model);\n            }\n        } else {\n            indexedDomainObjects[keyString] = objectToIndex;\n        }\n    }\n\n    /**\n     * Gets search results from the indexedItems based on provided search\n     *   input. Returns matching results from indexedItems\n     *\n     * @param data An object which contains:\n     *           * input: The original string which we are searching with\n     *           * maxResults: The maximum number of search results desired\n     *           * queryId: an id identifying this query, will be returned.\n     */\n    function searchForObjects(data) {\n        let results = [];\n        const input = data.input.trim().toLowerCase();\n        const message = {\n            request: 'searchForObjects',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        results = Object.values(indexedDomainObjects).filter((indexedItem) => {\n            return indexedItem.name.toLowerCase().includes(input);\n        }) || [];\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n\n    function searchForAnnotations(data) {\n        let results = [];\n        const message = {\n            request: 'searchForAnnotations',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        results = indexedAnnotationsByDomainObject[data.input] || [];\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n\n    function searchForTags(data) {\n        let results = [];\n        const message = {\n            request: 'searchForTags',\n            results: [],\n            total: 0,\n            queryId: data.queryId\n        };\n\n        if (data.input) {\n            data.input.forEach(matchingTag => {\n                const matchingAnnotations = indexedAnnotationsByTag[matchingTag];\n                if (matchingAnnotations) {\n                    matchingAnnotations.forEach(matchingAnnotation => {\n                        const existsInResults = results.some(indexedObject => {\n                            return matchingAnnotation.keyString === indexedObject.keyString;\n                        });\n                        if (!existsInResults) {\n                            results.push(matchingAnnotation);\n                        }\n                    });\n                }\n            });\n        }\n\n        message.total = results.length;\n        message.results = results\n            .slice(0, data.maxResults);\n\n        return message;\n    }\n}());\n"],"names":["root","factory","exports","module","define","amd","this","indexedDomainObjects","indexedAnnotationsByDomainObject","indexedAnnotationsByTag","self","onconnect","e","port","ports","onmessage","event","requestType","data","request","keyString","model","objectToIndex","type","name","targets","Object","keys","forEach","targetID","tags","some","indexedObject","push","indexAnnotation","tagID","filter","indexedTag","includes","tagToRemoveFromIndex","indexedAnnotation","indexTags","indexItem","postMessage","results","input","trim","toLowerCase","message","total","queryId","values","indexedItem","length","slice","maxResults","searchForObjects","searchForAnnotations","Error","matchingTag","matchingAnnotations","matchingAnnotation","searchForTags","start","onerror","error","console"],"sourceRoot":""}